// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'common.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Count _$CountFromJson(Map<String, dynamic> json) {
  return _Count.fromJson(json);
}

/// @nodoc
mixin _$Count {
  int? get all => throw _privateConstructorUsedError;
  int? get rated => throw _privateConstructorUsedError;
  int? get ai => throw _privateConstructorUsedError;
  int? get draw => throw _privateConstructorUsedError;
  int? get drawH => throw _privateConstructorUsedError;
  int? get loss => throw _privateConstructorUsedError;
  int? get lossH => throw _privateConstructorUsedError;
  int? get win => throw _privateConstructorUsedError;
  int? get winH => throw _privateConstructorUsedError;
  int? get bookmark => throw _privateConstructorUsedError;
  int? get playing => throw _privateConstructorUsedError;
  int? get import => throw _privateConstructorUsedError;
  int? get me => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CountCopyWith<Count> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountCopyWith<$Res> {
  factory $CountCopyWith(Count value, $Res Function(Count) then) =
      _$CountCopyWithImpl<$Res, Count>;
  @useResult
  $Res call(
      {int? all,
      int? rated,
      int? ai,
      int? draw,
      int? drawH,
      int? loss,
      int? lossH,
      int? win,
      int? winH,
      int? bookmark,
      int? playing,
      int? import,
      int? me});
}

/// @nodoc
class _$CountCopyWithImpl<$Res, $Val extends Count>
    implements $CountCopyWith<$Res> {
  _$CountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? all = freezed,
    Object? rated = freezed,
    Object? ai = freezed,
    Object? draw = freezed,
    Object? drawH = freezed,
    Object? loss = freezed,
    Object? lossH = freezed,
    Object? win = freezed,
    Object? winH = freezed,
    Object? bookmark = freezed,
    Object? playing = freezed,
    Object? import = freezed,
    Object? me = freezed,
  }) {
    return _then(_value.copyWith(
      all: freezed == all
          ? _value.all
          : all // ignore: cast_nullable_to_non_nullable
              as int?,
      rated: freezed == rated
          ? _value.rated
          : rated // ignore: cast_nullable_to_non_nullable
              as int?,
      ai: freezed == ai
          ? _value.ai
          : ai // ignore: cast_nullable_to_non_nullable
              as int?,
      draw: freezed == draw
          ? _value.draw
          : draw // ignore: cast_nullable_to_non_nullable
              as int?,
      drawH: freezed == drawH
          ? _value.drawH
          : drawH // ignore: cast_nullable_to_non_nullable
              as int?,
      loss: freezed == loss
          ? _value.loss
          : loss // ignore: cast_nullable_to_non_nullable
              as int?,
      lossH: freezed == lossH
          ? _value.lossH
          : lossH // ignore: cast_nullable_to_non_nullable
              as int?,
      win: freezed == win
          ? _value.win
          : win // ignore: cast_nullable_to_non_nullable
              as int?,
      winH: freezed == winH
          ? _value.winH
          : winH // ignore: cast_nullable_to_non_nullable
              as int?,
      bookmark: freezed == bookmark
          ? _value.bookmark
          : bookmark // ignore: cast_nullable_to_non_nullable
              as int?,
      playing: freezed == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as int?,
      import: freezed == import
          ? _value.import
          : import // ignore: cast_nullable_to_non_nullable
              as int?,
      me: freezed == me
          ? _value.me
          : me // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CountCopyWith<$Res> implements $CountCopyWith<$Res> {
  factory _$$_CountCopyWith(_$_Count value, $Res Function(_$_Count) then) =
      __$$_CountCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? all,
      int? rated,
      int? ai,
      int? draw,
      int? drawH,
      int? loss,
      int? lossH,
      int? win,
      int? winH,
      int? bookmark,
      int? playing,
      int? import,
      int? me});
}

/// @nodoc
class __$$_CountCopyWithImpl<$Res> extends _$CountCopyWithImpl<$Res, _$_Count>
    implements _$$_CountCopyWith<$Res> {
  __$$_CountCopyWithImpl(_$_Count _value, $Res Function(_$_Count) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? all = freezed,
    Object? rated = freezed,
    Object? ai = freezed,
    Object? draw = freezed,
    Object? drawH = freezed,
    Object? loss = freezed,
    Object? lossH = freezed,
    Object? win = freezed,
    Object? winH = freezed,
    Object? bookmark = freezed,
    Object? playing = freezed,
    Object? import = freezed,
    Object? me = freezed,
  }) {
    return _then(_$_Count(
      all: freezed == all
          ? _value.all
          : all // ignore: cast_nullable_to_non_nullable
              as int?,
      rated: freezed == rated
          ? _value.rated
          : rated // ignore: cast_nullable_to_non_nullable
              as int?,
      ai: freezed == ai
          ? _value.ai
          : ai // ignore: cast_nullable_to_non_nullable
              as int?,
      draw: freezed == draw
          ? _value.draw
          : draw // ignore: cast_nullable_to_non_nullable
              as int?,
      drawH: freezed == drawH
          ? _value.drawH
          : drawH // ignore: cast_nullable_to_non_nullable
              as int?,
      loss: freezed == loss
          ? _value.loss
          : loss // ignore: cast_nullable_to_non_nullable
              as int?,
      lossH: freezed == lossH
          ? _value.lossH
          : lossH // ignore: cast_nullable_to_non_nullable
              as int?,
      win: freezed == win
          ? _value.win
          : win // ignore: cast_nullable_to_non_nullable
              as int?,
      winH: freezed == winH
          ? _value.winH
          : winH // ignore: cast_nullable_to_non_nullable
              as int?,
      bookmark: freezed == bookmark
          ? _value.bookmark
          : bookmark // ignore: cast_nullable_to_non_nullable
              as int?,
      playing: freezed == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as int?,
      import: freezed == import
          ? _value.import
          : import // ignore: cast_nullable_to_non_nullable
              as int?,
      me: freezed == me
          ? _value.me
          : me // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Count implements _Count {
  const _$_Count(
      {this.all,
      this.rated,
      this.ai,
      this.draw,
      this.drawH,
      this.loss,
      this.lossH,
      this.win,
      this.winH,
      this.bookmark,
      this.playing,
      this.import,
      this.me});

  factory _$_Count.fromJson(Map<String, dynamic> json) =>
      _$$_CountFromJson(json);

  @override
  final int? all;
  @override
  final int? rated;
  @override
  final int? ai;
  @override
  final int? draw;
  @override
  final int? drawH;
  @override
  final int? loss;
  @override
  final int? lossH;
  @override
  final int? win;
  @override
  final int? winH;
  @override
  final int? bookmark;
  @override
  final int? playing;
  @override
  final int? import;
  @override
  final int? me;

  @override
  String toString() {
    return 'Count(all: $all, rated: $rated, ai: $ai, draw: $draw, drawH: $drawH, loss: $loss, lossH: $lossH, win: $win, winH: $winH, bookmark: $bookmark, playing: $playing, import: $import, me: $me)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Count &&
            (identical(other.all, all) || other.all == all) &&
            (identical(other.rated, rated) || other.rated == rated) &&
            (identical(other.ai, ai) || other.ai == ai) &&
            (identical(other.draw, draw) || other.draw == draw) &&
            (identical(other.drawH, drawH) || other.drawH == drawH) &&
            (identical(other.loss, loss) || other.loss == loss) &&
            (identical(other.lossH, lossH) || other.lossH == lossH) &&
            (identical(other.win, win) || other.win == win) &&
            (identical(other.winH, winH) || other.winH == winH) &&
            (identical(other.bookmark, bookmark) ||
                other.bookmark == bookmark) &&
            (identical(other.playing, playing) || other.playing == playing) &&
            (identical(other.import, import) || other.import == import) &&
            (identical(other.me, me) || other.me == me));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, all, rated, ai, draw, drawH,
      loss, lossH, win, winH, bookmark, playing, import, me);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CountCopyWith<_$_Count> get copyWith =>
      __$$_CountCopyWithImpl<_$_Count>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CountToJson(
      this,
    );
  }
}

abstract class _Count implements Count {
  const factory _Count(
      {final int? all,
      final int? rated,
      final int? ai,
      final int? draw,
      final int? drawH,
      final int? loss,
      final int? lossH,
      final int? win,
      final int? winH,
      final int? bookmark,
      final int? playing,
      final int? import,
      final int? me}) = _$_Count;

  factory _Count.fromJson(Map<String, dynamic> json) = _$_Count.fromJson;

  @override
  int? get all;
  @override
  int? get rated;
  @override
  int? get ai;
  @override
  int? get draw;
  @override
  int? get drawH;
  @override
  int? get loss;
  @override
  int? get lossH;
  @override
  int? get win;
  @override
  int? get winH;
  @override
  int? get bookmark;
  @override
  int? get playing;
  @override
  int? get import;
  @override
  int? get me;
  @override
  @JsonKey(ignore: true)
  _$$_CountCopyWith<_$_Count> get copyWith =>
      throw _privateConstructorUsedError;
}

PlayTime _$PlayTimeFromJson(Map<String, dynamic> json) {
  return _PlayTime.fromJson(json);
}

/// @nodoc
mixin _$PlayTime {
  int? get total => throw _privateConstructorUsedError;
  int? get tv => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PlayTimeCopyWith<PlayTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlayTimeCopyWith<$Res> {
  factory $PlayTimeCopyWith(PlayTime value, $Res Function(PlayTime) then) =
      _$PlayTimeCopyWithImpl<$Res, PlayTime>;
  @useResult
  $Res call({int? total, int? tv});
}

/// @nodoc
class _$PlayTimeCopyWithImpl<$Res, $Val extends PlayTime>
    implements $PlayTimeCopyWith<$Res> {
  _$PlayTimeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = freezed,
    Object? tv = freezed,
  }) {
    return _then(_value.copyWith(
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
      tv: freezed == tv
          ? _value.tv
          : tv // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PlayTimeCopyWith<$Res> implements $PlayTimeCopyWith<$Res> {
  factory _$$_PlayTimeCopyWith(
          _$_PlayTime value, $Res Function(_$_PlayTime) then) =
      __$$_PlayTimeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? total, int? tv});
}

/// @nodoc
class __$$_PlayTimeCopyWithImpl<$Res>
    extends _$PlayTimeCopyWithImpl<$Res, _$_PlayTime>
    implements _$$_PlayTimeCopyWith<$Res> {
  __$$_PlayTimeCopyWithImpl(
      _$_PlayTime _value, $Res Function(_$_PlayTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = freezed,
    Object? tv = freezed,
  }) {
    return _then(_$_PlayTime(
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int?,
      tv: freezed == tv
          ? _value.tv
          : tv // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PlayTime implements _PlayTime {
  const _$_PlayTime({this.total, this.tv});

  factory _$_PlayTime.fromJson(Map<String, dynamic> json) =>
      _$$_PlayTimeFromJson(json);

  @override
  final int? total;
  @override
  final int? tv;

  @override
  String toString() {
    return 'PlayTime(total: $total, tv: $tv)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PlayTime &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.tv, tv) || other.tv == tv));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, total, tv);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PlayTimeCopyWith<_$_PlayTime> get copyWith =>
      __$$_PlayTimeCopyWithImpl<_$_PlayTime>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PlayTimeToJson(
      this,
    );
  }
}

abstract class _PlayTime implements PlayTime {
  const factory _PlayTime({final int? total, final int? tv}) = _$_PlayTime;

  factory _PlayTime.fromJson(Map<String, dynamic> json) = _$_PlayTime.fromJson;

  @override
  int? get total;
  @override
  int? get tv;
  @override
  @JsonKey(ignore: true)
  _$$_PlayTimeCopyWith<_$_PlayTime> get copyWith =>
      throw _privateConstructorUsedError;
}

Perf _$PerfFromJson(Map<String, dynamic> json) {
  return _Perf.fromJson(json);
}

/// @nodoc
mixin _$Perf {
  int? get games => throw _privateConstructorUsedError;
  int? get rating => throw _privateConstructorUsedError;
  int? get rd => throw _privateConstructorUsedError;
  int? get prog => throw _privateConstructorUsedError;
  bool? get prov => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PerfCopyWith<Perf> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PerfCopyWith<$Res> {
  factory $PerfCopyWith(Perf value, $Res Function(Perf) then) =
      _$PerfCopyWithImpl<$Res, Perf>;
  @useResult
  $Res call({int? games, int? rating, int? rd, int? prog, bool? prov});
}

/// @nodoc
class _$PerfCopyWithImpl<$Res, $Val extends Perf>
    implements $PerfCopyWith<$Res> {
  _$PerfCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? games = freezed,
    Object? rating = freezed,
    Object? rd = freezed,
    Object? prog = freezed,
    Object? prov = freezed,
  }) {
    return _then(_value.copyWith(
      games: freezed == games
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as int?,
      rating: freezed == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as int?,
      rd: freezed == rd
          ? _value.rd
          : rd // ignore: cast_nullable_to_non_nullable
              as int?,
      prog: freezed == prog
          ? _value.prog
          : prog // ignore: cast_nullable_to_non_nullable
              as int?,
      prov: freezed == prov
          ? _value.prov
          : prov // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PerfCopyWith<$Res> implements $PerfCopyWith<$Res> {
  factory _$$_PerfCopyWith(_$_Perf value, $Res Function(_$_Perf) then) =
      __$$_PerfCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? games, int? rating, int? rd, int? prog, bool? prov});
}

/// @nodoc
class __$$_PerfCopyWithImpl<$Res> extends _$PerfCopyWithImpl<$Res, _$_Perf>
    implements _$$_PerfCopyWith<$Res> {
  __$$_PerfCopyWithImpl(_$_Perf _value, $Res Function(_$_Perf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? games = freezed,
    Object? rating = freezed,
    Object? rd = freezed,
    Object? prog = freezed,
    Object? prov = freezed,
  }) {
    return _then(_$_Perf(
      games: freezed == games
          ? _value.games
          : games // ignore: cast_nullable_to_non_nullable
              as int?,
      rating: freezed == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as int?,
      rd: freezed == rd
          ? _value.rd
          : rd // ignore: cast_nullable_to_non_nullable
              as int?,
      prog: freezed == prog
          ? _value.prog
          : prog // ignore: cast_nullable_to_non_nullable
              as int?,
      prov: freezed == prov
          ? _value.prov
          : prov // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Perf implements _Perf {
  const _$_Perf({this.games, this.rating, this.rd, this.prog, this.prov});

  factory _$_Perf.fromJson(Map<String, dynamic> json) => _$$_PerfFromJson(json);

  @override
  final int? games;
  @override
  final int? rating;
  @override
  final int? rd;
  @override
  final int? prog;
  @override
  final bool? prov;

  @override
  String toString() {
    return 'Perf(games: $games, rating: $rating, rd: $rd, prog: $prog, prov: $prov)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Perf &&
            (identical(other.games, games) || other.games == games) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            (identical(other.rd, rd) || other.rd == rd) &&
            (identical(other.prog, prog) || other.prog == prog) &&
            (identical(other.prov, prov) || other.prov == prov));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, games, rating, rd, prog, prov);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PerfCopyWith<_$_Perf> get copyWith =>
      __$$_PerfCopyWithImpl<_$_Perf>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PerfToJson(
      this,
    );
  }
}

abstract class _Perf implements Perf {
  const factory _Perf(
      {final int? games,
      final int? rating,
      final int? rd,
      final int? prog,
      final bool? prov}) = _$_Perf;

  factory _Perf.fromJson(Map<String, dynamic> json) = _$_Perf.fromJson;

  @override
  int? get games;
  @override
  int? get rating;
  @override
  int? get rd;
  @override
  int? get prog;
  @override
  bool? get prov;
  @override
  @JsonKey(ignore: true)
  _$$_PerfCopyWith<_$_Perf> get copyWith => throw _privateConstructorUsedError;
}

StormPerf _$StormPerfFromJson(Map<String, dynamic> json) {
  return _StormPerf.fromJson(json);
}

/// @nodoc
mixin _$StormPerf {
  int? get runs => throw _privateConstructorUsedError;
  int? get score => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StormPerfCopyWith<StormPerf> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StormPerfCopyWith<$Res> {
  factory $StormPerfCopyWith(StormPerf value, $Res Function(StormPerf) then) =
      _$StormPerfCopyWithImpl<$Res, StormPerf>;
  @useResult
  $Res call({int? runs, int? score});
}

/// @nodoc
class _$StormPerfCopyWithImpl<$Res, $Val extends StormPerf>
    implements $StormPerfCopyWith<$Res> {
  _$StormPerfCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? runs = freezed,
    Object? score = freezed,
  }) {
    return _then(_value.copyWith(
      runs: freezed == runs
          ? _value.runs
          : runs // ignore: cast_nullable_to_non_nullable
              as int?,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StormPerfCopyWith<$Res> implements $StormPerfCopyWith<$Res> {
  factory _$$_StormPerfCopyWith(
          _$_StormPerf value, $Res Function(_$_StormPerf) then) =
      __$$_StormPerfCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? runs, int? score});
}

/// @nodoc
class __$$_StormPerfCopyWithImpl<$Res>
    extends _$StormPerfCopyWithImpl<$Res, _$_StormPerf>
    implements _$$_StormPerfCopyWith<$Res> {
  __$$_StormPerfCopyWithImpl(
      _$_StormPerf _value, $Res Function(_$_StormPerf) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? runs = freezed,
    Object? score = freezed,
  }) {
    return _then(_$_StormPerf(
      runs: freezed == runs
          ? _value.runs
          : runs // ignore: cast_nullable_to_non_nullable
              as int?,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_StormPerf implements _StormPerf {
  const _$_StormPerf({this.runs, this.score});

  factory _$_StormPerf.fromJson(Map<String, dynamic> json) =>
      _$$_StormPerfFromJson(json);

  @override
  final int? runs;
  @override
  final int? score;

  @override
  String toString() {
    return 'StormPerf(runs: $runs, score: $score)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StormPerf &&
            (identical(other.runs, runs) || other.runs == runs) &&
            (identical(other.score, score) || other.score == score));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, runs, score);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StormPerfCopyWith<_$_StormPerf> get copyWith =>
      __$$_StormPerfCopyWithImpl<_$_StormPerf>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_StormPerfToJson(
      this,
    );
  }
}

abstract class _StormPerf implements StormPerf {
  const factory _StormPerf({final int? runs, final int? score}) = _$_StormPerf;

  factory _StormPerf.fromJson(Map<String, dynamic> json) =
      _$_StormPerf.fromJson;

  @override
  int? get runs;
  @override
  int? get score;
  @override
  @JsonKey(ignore: true)
  _$$_StormPerfCopyWith<_$_StormPerf> get copyWith =>
      throw _privateConstructorUsedError;
}

Perfs _$PerfsFromJson(Map<String, dynamic> json) {
  return _Perfs.fromJson(json);
}

/// @nodoc
mixin _$Perfs {
  Perf? get chess960 => throw _privateConstructorUsedError;
  Perf? get atomic => throw _privateConstructorUsedError;
  Perf? get racingKings => throw _privateConstructorUsedError;
  Perf? get ultraBullet => throw _privateConstructorUsedError;
  Perf? get blitz => throw _privateConstructorUsedError;
  Perf? get kingOfTheHill => throw _privateConstructorUsedError;
  Perf? get bullet => throw _privateConstructorUsedError;
  Perf? get correspondence => throw _privateConstructorUsedError;
  Perf? get horde => throw _privateConstructorUsedError;
  Perf? get puzzle => throw _privateConstructorUsedError;
  Perf? get classical => throw _privateConstructorUsedError;
  Perf? get rapid => throw _privateConstructorUsedError;
  StormPerf? get storm => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PerfsCopyWith<Perfs> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PerfsCopyWith<$Res> {
  factory $PerfsCopyWith(Perfs value, $Res Function(Perfs) then) =
      _$PerfsCopyWithImpl<$Res, Perfs>;
  @useResult
  $Res call(
      {Perf? chess960,
      Perf? atomic,
      Perf? racingKings,
      Perf? ultraBullet,
      Perf? blitz,
      Perf? kingOfTheHill,
      Perf? bullet,
      Perf? correspondence,
      Perf? horde,
      Perf? puzzle,
      Perf? classical,
      Perf? rapid,
      StormPerf? storm});

  $PerfCopyWith<$Res>? get chess960;
  $PerfCopyWith<$Res>? get atomic;
  $PerfCopyWith<$Res>? get racingKings;
  $PerfCopyWith<$Res>? get ultraBullet;
  $PerfCopyWith<$Res>? get blitz;
  $PerfCopyWith<$Res>? get kingOfTheHill;
  $PerfCopyWith<$Res>? get bullet;
  $PerfCopyWith<$Res>? get correspondence;
  $PerfCopyWith<$Res>? get horde;
  $PerfCopyWith<$Res>? get puzzle;
  $PerfCopyWith<$Res>? get classical;
  $PerfCopyWith<$Res>? get rapid;
  $StormPerfCopyWith<$Res>? get storm;
}

/// @nodoc
class _$PerfsCopyWithImpl<$Res, $Val extends Perfs>
    implements $PerfsCopyWith<$Res> {
  _$PerfsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chess960 = freezed,
    Object? atomic = freezed,
    Object? racingKings = freezed,
    Object? ultraBullet = freezed,
    Object? blitz = freezed,
    Object? kingOfTheHill = freezed,
    Object? bullet = freezed,
    Object? correspondence = freezed,
    Object? horde = freezed,
    Object? puzzle = freezed,
    Object? classical = freezed,
    Object? rapid = freezed,
    Object? storm = freezed,
  }) {
    return _then(_value.copyWith(
      chess960: freezed == chess960
          ? _value.chess960
          : chess960 // ignore: cast_nullable_to_non_nullable
              as Perf?,
      atomic: freezed == atomic
          ? _value.atomic
          : atomic // ignore: cast_nullable_to_non_nullable
              as Perf?,
      racingKings: freezed == racingKings
          ? _value.racingKings
          : racingKings // ignore: cast_nullable_to_non_nullable
              as Perf?,
      ultraBullet: freezed == ultraBullet
          ? _value.ultraBullet
          : ultraBullet // ignore: cast_nullable_to_non_nullable
              as Perf?,
      blitz: freezed == blitz
          ? _value.blitz
          : blitz // ignore: cast_nullable_to_non_nullable
              as Perf?,
      kingOfTheHill: freezed == kingOfTheHill
          ? _value.kingOfTheHill
          : kingOfTheHill // ignore: cast_nullable_to_non_nullable
              as Perf?,
      bullet: freezed == bullet
          ? _value.bullet
          : bullet // ignore: cast_nullable_to_non_nullable
              as Perf?,
      correspondence: freezed == correspondence
          ? _value.correspondence
          : correspondence // ignore: cast_nullable_to_non_nullable
              as Perf?,
      horde: freezed == horde
          ? _value.horde
          : horde // ignore: cast_nullable_to_non_nullable
              as Perf?,
      puzzle: freezed == puzzle
          ? _value.puzzle
          : puzzle // ignore: cast_nullable_to_non_nullable
              as Perf?,
      classical: freezed == classical
          ? _value.classical
          : classical // ignore: cast_nullable_to_non_nullable
              as Perf?,
      rapid: freezed == rapid
          ? _value.rapid
          : rapid // ignore: cast_nullable_to_non_nullable
              as Perf?,
      storm: freezed == storm
          ? _value.storm
          : storm // ignore: cast_nullable_to_non_nullable
              as StormPerf?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get chess960 {
    if (_value.chess960 == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.chess960!, (value) {
      return _then(_value.copyWith(chess960: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get atomic {
    if (_value.atomic == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.atomic!, (value) {
      return _then(_value.copyWith(atomic: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get racingKings {
    if (_value.racingKings == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.racingKings!, (value) {
      return _then(_value.copyWith(racingKings: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get ultraBullet {
    if (_value.ultraBullet == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.ultraBullet!, (value) {
      return _then(_value.copyWith(ultraBullet: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get blitz {
    if (_value.blitz == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.blitz!, (value) {
      return _then(_value.copyWith(blitz: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get kingOfTheHill {
    if (_value.kingOfTheHill == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.kingOfTheHill!, (value) {
      return _then(_value.copyWith(kingOfTheHill: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get bullet {
    if (_value.bullet == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.bullet!, (value) {
      return _then(_value.copyWith(bullet: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get correspondence {
    if (_value.correspondence == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.correspondence!, (value) {
      return _then(_value.copyWith(correspondence: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get horde {
    if (_value.horde == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.horde!, (value) {
      return _then(_value.copyWith(horde: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get puzzle {
    if (_value.puzzle == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.puzzle!, (value) {
      return _then(_value.copyWith(puzzle: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get classical {
    if (_value.classical == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.classical!, (value) {
      return _then(_value.copyWith(classical: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PerfCopyWith<$Res>? get rapid {
    if (_value.rapid == null) {
      return null;
    }

    return $PerfCopyWith<$Res>(_value.rapid!, (value) {
      return _then(_value.copyWith(rapid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $StormPerfCopyWith<$Res>? get storm {
    if (_value.storm == null) {
      return null;
    }

    return $StormPerfCopyWith<$Res>(_value.storm!, (value) {
      return _then(_value.copyWith(storm: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PerfsCopyWith<$Res> implements $PerfsCopyWith<$Res> {
  factory _$$_PerfsCopyWith(_$_Perfs value, $Res Function(_$_Perfs) then) =
      __$$_PerfsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Perf? chess960,
      Perf? atomic,
      Perf? racingKings,
      Perf? ultraBullet,
      Perf? blitz,
      Perf? kingOfTheHill,
      Perf? bullet,
      Perf? correspondence,
      Perf? horde,
      Perf? puzzle,
      Perf? classical,
      Perf? rapid,
      StormPerf? storm});

  @override
  $PerfCopyWith<$Res>? get chess960;
  @override
  $PerfCopyWith<$Res>? get atomic;
  @override
  $PerfCopyWith<$Res>? get racingKings;
  @override
  $PerfCopyWith<$Res>? get ultraBullet;
  @override
  $PerfCopyWith<$Res>? get blitz;
  @override
  $PerfCopyWith<$Res>? get kingOfTheHill;
  @override
  $PerfCopyWith<$Res>? get bullet;
  @override
  $PerfCopyWith<$Res>? get correspondence;
  @override
  $PerfCopyWith<$Res>? get horde;
  @override
  $PerfCopyWith<$Res>? get puzzle;
  @override
  $PerfCopyWith<$Res>? get classical;
  @override
  $PerfCopyWith<$Res>? get rapid;
  @override
  $StormPerfCopyWith<$Res>? get storm;
}

/// @nodoc
class __$$_PerfsCopyWithImpl<$Res> extends _$PerfsCopyWithImpl<$Res, _$_Perfs>
    implements _$$_PerfsCopyWith<$Res> {
  __$$_PerfsCopyWithImpl(_$_Perfs _value, $Res Function(_$_Perfs) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chess960 = freezed,
    Object? atomic = freezed,
    Object? racingKings = freezed,
    Object? ultraBullet = freezed,
    Object? blitz = freezed,
    Object? kingOfTheHill = freezed,
    Object? bullet = freezed,
    Object? correspondence = freezed,
    Object? horde = freezed,
    Object? puzzle = freezed,
    Object? classical = freezed,
    Object? rapid = freezed,
    Object? storm = freezed,
  }) {
    return _then(_$_Perfs(
      chess960: freezed == chess960
          ? _value.chess960
          : chess960 // ignore: cast_nullable_to_non_nullable
              as Perf?,
      atomic: freezed == atomic
          ? _value.atomic
          : atomic // ignore: cast_nullable_to_non_nullable
              as Perf?,
      racingKings: freezed == racingKings
          ? _value.racingKings
          : racingKings // ignore: cast_nullable_to_non_nullable
              as Perf?,
      ultraBullet: freezed == ultraBullet
          ? _value.ultraBullet
          : ultraBullet // ignore: cast_nullable_to_non_nullable
              as Perf?,
      blitz: freezed == blitz
          ? _value.blitz
          : blitz // ignore: cast_nullable_to_non_nullable
              as Perf?,
      kingOfTheHill: freezed == kingOfTheHill
          ? _value.kingOfTheHill
          : kingOfTheHill // ignore: cast_nullable_to_non_nullable
              as Perf?,
      bullet: freezed == bullet
          ? _value.bullet
          : bullet // ignore: cast_nullable_to_non_nullable
              as Perf?,
      correspondence: freezed == correspondence
          ? _value.correspondence
          : correspondence // ignore: cast_nullable_to_non_nullable
              as Perf?,
      horde: freezed == horde
          ? _value.horde
          : horde // ignore: cast_nullable_to_non_nullable
              as Perf?,
      puzzle: freezed == puzzle
          ? _value.puzzle
          : puzzle // ignore: cast_nullable_to_non_nullable
              as Perf?,
      classical: freezed == classical
          ? _value.classical
          : classical // ignore: cast_nullable_to_non_nullable
              as Perf?,
      rapid: freezed == rapid
          ? _value.rapid
          : rapid // ignore: cast_nullable_to_non_nullable
              as Perf?,
      storm: freezed == storm
          ? _value.storm
          : storm // ignore: cast_nullable_to_non_nullable
              as StormPerf?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Perfs implements _Perfs {
  const _$_Perfs(
      {this.chess960,
      this.atomic,
      this.racingKings,
      this.ultraBullet,
      this.blitz,
      this.kingOfTheHill,
      this.bullet,
      this.correspondence,
      this.horde,
      this.puzzle,
      this.classical,
      this.rapid,
      this.storm});

  factory _$_Perfs.fromJson(Map<String, dynamic> json) =>
      _$$_PerfsFromJson(json);

  @override
  final Perf? chess960;
  @override
  final Perf? atomic;
  @override
  final Perf? racingKings;
  @override
  final Perf? ultraBullet;
  @override
  final Perf? blitz;
  @override
  final Perf? kingOfTheHill;
  @override
  final Perf? bullet;
  @override
  final Perf? correspondence;
  @override
  final Perf? horde;
  @override
  final Perf? puzzle;
  @override
  final Perf? classical;
  @override
  final Perf? rapid;
  @override
  final StormPerf? storm;

  @override
  String toString() {
    return 'Perfs(chess960: $chess960, atomic: $atomic, racingKings: $racingKings, ultraBullet: $ultraBullet, blitz: $blitz, kingOfTheHill: $kingOfTheHill, bullet: $bullet, correspondence: $correspondence, horde: $horde, puzzle: $puzzle, classical: $classical, rapid: $rapid, storm: $storm)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Perfs &&
            (identical(other.chess960, chess960) ||
                other.chess960 == chess960) &&
            (identical(other.atomic, atomic) || other.atomic == atomic) &&
            (identical(other.racingKings, racingKings) ||
                other.racingKings == racingKings) &&
            (identical(other.ultraBullet, ultraBullet) ||
                other.ultraBullet == ultraBullet) &&
            (identical(other.blitz, blitz) || other.blitz == blitz) &&
            (identical(other.kingOfTheHill, kingOfTheHill) ||
                other.kingOfTheHill == kingOfTheHill) &&
            (identical(other.bullet, bullet) || other.bullet == bullet) &&
            (identical(other.correspondence, correspondence) ||
                other.correspondence == correspondence) &&
            (identical(other.horde, horde) || other.horde == horde) &&
            (identical(other.puzzle, puzzle) || other.puzzle == puzzle) &&
            (identical(other.classical, classical) ||
                other.classical == classical) &&
            (identical(other.rapid, rapid) || other.rapid == rapid) &&
            (identical(other.storm, storm) || other.storm == storm));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      chess960,
      atomic,
      racingKings,
      ultraBullet,
      blitz,
      kingOfTheHill,
      bullet,
      correspondence,
      horde,
      puzzle,
      classical,
      rapid,
      storm);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PerfsCopyWith<_$_Perfs> get copyWith =>
      __$$_PerfsCopyWithImpl<_$_Perfs>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PerfsToJson(
      this,
    );
  }
}

abstract class _Perfs implements Perfs {
  const factory _Perfs(
      {final Perf? chess960,
      final Perf? atomic,
      final Perf? racingKings,
      final Perf? ultraBullet,
      final Perf? blitz,
      final Perf? kingOfTheHill,
      final Perf? bullet,
      final Perf? correspondence,
      final Perf? horde,
      final Perf? puzzle,
      final Perf? classical,
      final Perf? rapid,
      final StormPerf? storm}) = _$_Perfs;

  factory _Perfs.fromJson(Map<String, dynamic> json) = _$_Perfs.fromJson;

  @override
  Perf? get chess960;
  @override
  Perf? get atomic;
  @override
  Perf? get racingKings;
  @override
  Perf? get ultraBullet;
  @override
  Perf? get blitz;
  @override
  Perf? get kingOfTheHill;
  @override
  Perf? get bullet;
  @override
  Perf? get correspondence;
  @override
  Perf? get horde;
  @override
  Perf? get puzzle;
  @override
  Perf? get classical;
  @override
  Perf? get rapid;
  @override
  StormPerf? get storm;
  @override
  @JsonKey(ignore: true)
  _$$_PerfsCopyWith<_$_Perfs> get copyWith =>
      throw _privateConstructorUsedError;
}
